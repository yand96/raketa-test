
В первую очередь при ревью хотелось бы выделить несколько общих замечаний ко всей задача
1) declare(strict_types=1). Эту строчку нужно вставить в каждый php файл, чтобы у нас была строгая типизация. 
Строгая типизация помогает избежать ошибок, когда пхп автоматически приводит переменные к другому типу при неправильной 
их передаче в функцию или возвращаемому значению.
2) Необходима строгая типизация свойств класса, передаваемых и возвращаемых значений в функции. Это не реализовано
в CartManager.php

Архитектура:
То, как сейчас расположены файлы, указывает на то, что разработчик пытался придерживается слоистой архитектуры.
У него отдельно выделен слой бизнеса - Domain. Слой отображения - View. И слой взаимодействия с базой - Repository.
При этом отдельно лежать папки Controller и Infrastructure. Я считаю, что это ошибка и надо менять расположение папок.
Говоря общими словами в слоистой архитектуре выделяют три основные слоя: 
1) слой представления, который отвечает за взаимодействие с пользовательским интерфейсом(Назовем его Presentation) 
2) слой бизнеса, где реализована вся бизнеслогика приложения(Назовем его Domain)
3) слой доступа к данным, который взаимодействует с базой, брокерами, другими приложениями и тд (Назовем его DataAccess)
Исходя из этой логики необходимо создать папки Presentation и DataAccess. В папку Presentation мы переносим папки
Controller и View, так как в них находится логика взаимодействия с пользовательским интерфейсом. В папку DataAccess мы 
переносим папки Infrastructure и Repository, так как это взаимодействие с данными.

О каждой папке конкретнее:
Presentation
Как я писал ранее, в папке Presentation у нас находятся котроллеры и вьюшки к ним. В первую очередь я считаю, что в 
контроллерах не должна находится бизнес логика. Контроллер должен вытаскивать данные из реквеста, при необходимости 
собирать их в объект для слоя бизнеса(провалидировать, если это необходимо) и передавать их ему. После получания 
результата от слоя бизнеса в контроллере вызывается транслятор ответа(вьюшка в нашем случае) и возвращается ответ пользователю. 
Контроллер ни в коем случае не должен вызывать слой DataAccess для своей работы. Все взаимодействия с ним, если таковые 
нужны, должны происходить через слой Domain.
Чтобы убрать повторение кода, был написан абстрактный контроллер, от которого отнаследовались текущие три. Необходим для 
упрощения формирования ответа и чтобы убрать дублирование кода.

Трансляторы в папке View так же не должны содержать бизнес логику и взаимодействовать со слоем DataAccess напрямую.
Поэтому подсчет общей цены заказа в корзине нужно вынести на слой Domain. Вызов получения информации по продукту надо 
передлать: во-первых оптимальнее сделать один запрос к базе с несколькими uuid, чем несколько запросов по одному uuid, 
во-вторых нельзя вызывать слой DataAccess напрямую, поэтому создаем ProductService и делаем запрос через него.

Domain
Разработчик пытался сделать универсальный класс CartManager. При маштабировании проекта этот класс рискует превратиться в
"Божественный объект", что является антипатерном. Поэтому мы разделим этот класс на два сервиса, что соответствует принципу 
разработки DDD (Domain-Driven Design). Первый класс для получения корзины, а второй для дополнения в неё. 
Чтобы не дублировать код получения корзины, мы наследуем один сервис от второго. В будущем при масштабировании этот 
функционал можно будет вынести в абстрактный класс, но на данный момент в этом нет необходимости, поэтому так не делаем, 
ведь мы знаем про принцип KISS(Keep It Simple).
В реализации корзины основная ошибка это использование sessionId. Привязывать корзину к сессии это плохо, так как у нас
есть авторизованный пользователь и намного-намного лучше использовать ID пользователя. Особенно это поможет при масштабировании
проекта, когда будет мобильное приложение и тд. Так же при запросе корзины, если её нет у пользователя, то она автоматически 
создается пустой. Такая же логика, если пользователь пытается что-то добавить в корзину, а она уже "протухла" (прошло 
время жизни в редисе). Если такая логика неверная, то можно кидать ошибку на фронт, тут все зависит от бизнеса.
Кейс редкий, но лучше обработать. При добавлении в корзину не было реализовано её сохранение. Так же спорный момент с
добавление дублирующего продукта. Разработчик реализовал это так, что сейчас продукт добавляется как новая позиция. Если
это соответствует бизнес логике, то хорошо. Если нет - то должен находиться уже добавленный продукт и увеличиваться его 
счетчик кол-ва. В данном примере будем считать, что разработчик сделал все по ТЗ. 
Как я писал выше, расчет стоимости корзины это бизнес логика, поэтому я вынес это в слой Domain и добавил соответствующее 
поле в класс. Это поможет нам при масштабировании проекта не считать цену каждый раз "на лету", к примеру при сохранении 
корзины в уже созданный заказ или при расчете какой-нибудь скидки (условно если стоимость корзины выше 2000, то делаем 
скидку 5%). При создании новой корзины не указывался метод оплаты. Будем считать, что ставим дефолтный "online" и 
создадим для перечня всех возможных enum PaymentMethod. С его помощью можно будет делать валидацию входных значений, при
необходимости.

DataAccess
В этой папке у нас находятся репозитории и класс для взаимодействия с редисом. В репозитории я считаю ошибкой передавать
значения через конкатинацию. Намного лучше и безопаснее передавать их через параметры. Хоть по условиям задания входные 
данные провалидированны, лучше не рисковать и не передавать их на прямую, чтобы защититься от sql инъекций и тп. Так же 
в методе getByCategory в sql была допущена ошибка и выбирались не все данные, а только id. Это вызвало бы ошибку при 
дальнейшем выполнении кода. Так же был написан метод получения продуктов по массиву uuid. В нем передается константа
Connection::PARAM_STR_ARRAY, которая указывает доктрине, что переменная является массивом. В примере либы ее нет, но
считаем что он есть, так как так по условиям тз база настроена. 
Для архитиктуры важно уточнить, что Репозитории возвращают объекты слоя домейн в данной задаче только для упрощения кода,
так как мы не знаем сложность проекта и не хотим перегружать его дополнительным синтаксическим сахаром (помним про KISS).
В большом проекте должны быть отдельные сущности слоя DataAccess, которые в специальном мапере преобразуются в объекты
слоя Domain.

В папке Infrastructure лежит класс RedisConnector который отвечает за взаимодействие с редис. Из отличий от реализации в
примере это то, что коннект создается в момент явного обращения к функциям класса, а не при его инициализации. Это позволяет
нам не создавать лишние коннекты при инициализации пхп, когда они не нужны для выполнения кода. Как пример метод запроса 
продуктов, когда редис нам не нужен. Реализованно через паттерн Singleton. Время жизни корзины реализованно через TTL,
ключ состоит из префикса и id пользователя. Префикс помогает определить, что это сущность корзины, а id пользователя 
указывает на принадлежность корзины конкретному пользователю.  

Логирование
Все сервисы в /Domain/Service/Cart обернуты в try catch и добавлены логи на случай, если будет ошибка в ходе выполнения
Так как самого логера в задаче нет, то просто пишется сообщение, по которому можно понять, в каком месте у нас была ошибка,
текст самой ошибки и стектрейс. Дальше ошибка бы передаваласть в сервис, которые бы её парсил и отправлял в условную 
кибану или аналог.

SQL запрос
считаем uuid уникальным полем(добавили ей знак уникальности) с фиксированной длинной(uuid4), поэтому меняем его длину на char36.
В рамках бизнес ТЗ представим, что это внешний идентификатор в стороннем сервисе, где мы заказываем товары. 
Поле id остается нашим внутренним идентификатором для внутренних бизнес процессов. Уменьшаем длину полей name и 
category, так как скорее всего они не будут использовать всю длину varchar255. Поля description и thumbnail можно 
не трогать, но надо понимать, что если ссылка будет очень и очень длинной, то лучше увеличить размер поля thumbnail, 
чтобы mysql ее не обрезал, но для стандартных ссылок на картинки этого должно хватать
Дополнительный индекс на поле uuid делать нет смысла, так как поле уникальное и mysql навешает на него индекс "под капотом"